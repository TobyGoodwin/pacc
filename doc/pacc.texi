\input texinfo   @c -*-texinfo-*-
@comment $Id@w{$}
@comment %**start of header
@setfilename pacc.info
@documentencoding UTF-8
@include version.texi
@settitle pacc @value{VERSION}
@syncodeindex pg cp
@syncodeindex fn cp
@comment %**end of header
@copying
This manual is for GNU pacc (version @value{VERSION}, @value{UPDATED}),
which is a parser generator.

Copyright @copyright{} 2013 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
@end quotation
@end copying

@dircategory Texinfo documentation system
@direntry
* sample: (sample)Invoking sample.
@end direntry

@titlepage
@title pacc - a compiler-compiler
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Tobold J. Goodwin (@email{toby@@paccrat.org})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top pacc

This manual is for GNU pacc (version @value{VERSION}, @value{UPDATED}).
@end ifnottex

@menu
* Tutorial::
* User Manual::
* GNU Free Documentation License::
* Index::
@end menu

@node Tutorial
@chapter Tutorial

This tutorial introduces pacc with a series of examples.

@menu
* Parsing basics::
* Getting started::
* Pacc basics::
* Alternatives::
* Rules::
* Types::
* Referencing the input::
* Operators::
* Binding values to names::
* Expressing precedence::
* Handling whitespace::
* Associativity::
* Feeding example::
* Any matcher::
* Using lookahead::
@end menu

@node Parsing basics
@section Parsing basics

@cindex parser
@cindex formal language
@cindex computer language
@cindex language
A @dfn{parser} is a computer program that interprets the utterances of a
@dfn{computer language} A computer language is more properly known as a
@dfn{formal language}. It's unfortunate, in my opinion, that the word
``language'' is used here at all (although I can't think of a better word),
because formal languages are almost entirely @emph{un}like natural languages. A
skateboard and an aircraft carrier are both means of transport, but that's
about all they have in common!

Computer languages vary enormously in complexity: the most elaborate are
high-level programming languages. At the bottom end, the address box in a web
browser understands an extremely simple computer language, the majority of
whose utterances begin @samp{http://}! Somewhere in between is the language of
cells in a spreadsheet, in which one can say things like
@samp{=A2+3*sum(C7:C9)}.

Pacc is a @dfn{parser generator}. That means that we write a compact
description of a computer language, invoke @command{pacc} with that description
as its input, and pacc writes for us a parser for that language. The output of
pacc is a C function, which we can use to build a complete program.

When we run a program that includes a pacc-built parser, the program will
procure some input from somewhere---in most cases it will be a file, but it
could be the command line, or a GUI input---and hand that input to the parser.
The parser now has a couple of jobs to do.

First, it needs to decide if the input is in fact a valid utterance of the
language described by the grammar. For example, if the language is simple
arithmetic expressions, then @samp{2 * (3 + 4)} presumably @emph{is} a valid
utterance, whereas @samp{2 + * )( 3 4} is @emph{not}. If the input is erroneous
(not a valid utterance of the described language), then the parser needs to
indicate how much it could parse before it encountered an error. If we are
parsing a programming language, our utterances may be thousands of lines long,
so good error-handling is vital.

Secondly, if the input was valid, the parser needs to discern its meaning.  In
most cases, this will involve building an @dfn{Abstract Syntax Tree}
@acronym{AST} that captures the meaning of the input in a way that can easily
be manipulated by the rest of the program. (In our first examples, though, we
won't be building trees.)

@node Getting started
@section Getting started

Let's actually make a pacc parser. We'll start with about the simplest possible
language I can conceive of. In this language, there are just two valid
utterances: @strong{yes} and @strong{no}. The ``meaning'' of @strong{yes} will
be @strong{1}; @strong{no} will mean @strong{0}. This can be expressed in a
pacc grammar like this.

@verbatim
Start <- "yes" {1} / "no" {0}
@end verbatim

We'll worry about the details of exactly how that expresses the language we
described later on (although you can probably get the general idea). For now,
we want to turn this into an actual program, so the first thing to do is to put
that grammar into a file named @file{bool.pacc}.

Next, we'll need to supply the rest of the program. We'll keep it very
simple. Here's @file{main.c}.

@verbatim
#include <stdio.h>
#include <string.h>

#include "bool.h"

int main(int argc, char **argv) {
    int result;

    if (argc != 2) {
        fprintf(stderr, "one argument please\n");
        return 1;
    }

    if (pacc_wrap("arg", argv[1], strlen(argv[1]), &result))
        printf("parsed with value %d\n", result);

    else
        return 1;

    return 0;
}
@end verbatim

To build the program, we first need to invoke @command{pacc} on the grammar
definition. This will output @file{bool.c}. We specify the @option{-d} switch
to @command{pacc} so that it will also output @file{bool.h} which we included
in our program, and supplies the declaration of @code{pacc_wrap()}:

@example
pacc -d bool.pacc
@end example

Then simply compile as normal:

@example
gcc -o bool main.c bool.c
@end example

And here's what the program looks like in action:

@example
$ bool yes
parsed with value 1
$ bool no
parsed with value 0
$ bool foo
arg:1:1: expected Start
@end example

Which is what we wanted!

@node Pacc basics
@section Pacc basics

A pacc grammar consists of one or more @emph{rules}. Let's look at our
first example again.

@verbatim
Start <- "yes" {1} / "no" {0}
@end verbatim

There's just one rule in this tiny grammar. Every rule starts with a name, and
the name of this rule is @samp{Start}. The names of rules follow the same
conventions as identifiers in C.

After the name, a left arrow introduces the @emph{definition} of the rule. In
this case, we've made a left arrow out of two old-fashioned @acronym{ASCII}
symbols, @samp{<} and @samp{-}, but it's also permitted to use the Unicode
character @samp{←} (U+2190 @sc{leftwards arrow}). You can also use a plain old
equals sign @samp{=} if you prefer.

A pacc parser works by @dfn{matching} the input to the rules in the grammar.
The process starts with the first rule (in this case it's the only rule), and
the first thing in the definition of that first rule.  In the case of
@samp{Start}, the first thing in the definition is @samp{"yes"}. The quote
marks mean that this is a @dfn{literal string}. For a successful match, the
input must be exactly the same characters as are in the literal.

@cindex alternative
Let's suppose that on this occasion the input is @samp{no}. So the parser
can't match the input against @samp{"yes"} in the rule. But in this rule
there is an @dfn{alternative}, and the parser will try to match that next.
The @samp{/} character separates alternatives, so the next alternative
starts with another literal string: @samp{"no"}. This does match our
example input.

So having matched @samp{"no"} the parser then finds @samp{@{0@}}. The braces
indicate that this is a (tiny!) hunk of C code. Because it is in the
alternative that matched, it will be evaluated to give a value to the rule. And
the value of the start rule is the overall value of the parse.

@node Alternatives
@section Alternatives

@cartouche
@quotation
An absolutely crucial point to understand about pacc grammars is that
alternatives are tried @strong{in order}. The first alternative which matches
successfully is the one that ``wins'', and later alternatives aren't considered
at all.
@end quotation
@end cartouche

Let's go multi-lingual. (There are more elegant ways to write this,
which we'll come to soon.)

@verbatim
Start ← "yes" {1} / "oui" {1} / "no" {0} / "non" {0} # wrong!
@end verbatim

That may look like it should work, but this is what happens when we
try it:

@verbatim
  $ french0 oui
  parsed with value 1
  $ french0 no
  parsed with value 0
  $ french0 non
  arg:1:3: expected end-of-input
@end verbatim
  
What went wrong there? The problem is that the third alternative @samp{"no"}
matches the first two characters of the input @samp{non}, and so that becomes
the winning alternative, even though that leads to an overall failure. Pacc
parsers never ``back up'' once an alternative has completely matched.

For this simple grammar, the obvious fix is simply to swap the order of these
two alternatives. We'll see similar problems, and other fixes, later on.

@verbatim
Start ← "yes" {1} / "oui" {1} / "non" {0} / "no" {0}
@end verbatim

This grammar works as intended:

@verbatim
$ french1 no
parsed with value 0
$ french1 non
parsed with value 0
@end verbatim

This behaviour is the fundamental difference between @acronym{PEG}s (the style
of grammars that pacc uses) and @acronym{CFG} (the more traditional
alternative), so it may take you a while to get used to it.

@node Rules
@section Rules

Here's where we've got to:

@verbatim
Start ← "yes" {1} / "oui" {1} / "non" {0} / "no" {0}
@end verbatim

We can improve this by splitting things up and removing the repetition.

@verbatim
Start ← Yes → 1 / No → 0
Yes :: void ← "yes" / "oui"
No ← "non" / "no"
@end verbatim

Don't, at the moment, worry about @samp{:: void} on the second line---we'll
explain what this means shortly. The important point to notice is that a
grammar can have more than one rule. The first rule is always the start rule,
where parsing begins.

Each rule has a name, in this grammar there are 3 rules named @samp{Start},
@samp{Yes}, and @samp{No}. Rule names are formed in the same way as C
identifiers: they must start with a letter or underscore, and continue with
letters, underscores, or digits. I often follow the convention of starting
rule names with capital letters as it helps them to stand out, but you don't
have to.

The fundamental building blocks of pacc are called @dfn{matchers}.  We've
already met one kind of matcher: a literal string like @samp{"yes"}.  A matcher
occurs in the definition of a rule, and it matches something in the input. In
the case of a literal string, it matches just that one string.

Another kind of matcher is a @dfn{call matcher}.  One rule can call another
rule, simply by naming the called rule in its definition. As you might expect,
when you call a rule by name, that matches whatever the called rule matches.
The definition of the @samp{Start} rule contains two call matchers: the first
calls the rule @samp{Yes} and the second calls the rule @samp{No}. You can
call a rule before it has been defined, so long as the definition occurs in the
same pacc grammar.

There are only two other kinds of matcher, which we'll get to soon.

@node Types
@section Types

@cindex types

Every pacc rule has a @dfn{type}, which can be almost any C type.  The type of
a rule appears in its definition, directly after the name introduced by
@samp{::}. (In many ways, I would have preferred to prefix types to names like
C itself, but then we'd have to terminate rules, say with semicolons, and that
appealed even less.)

The rules for types are as follows.

@enumerate
@item If a rule has an explicit type, that is its type; otherwise
@item the rule has the same type as the previous rule; unless
@item it is the first rule, in which case the default type is @samp{int}.
@item Every path through a rule must include exactly one expression with the
type of the rule; unless
@item the type of the rule is @samp{void}, in which case no expressions are
allowed.
@end enumerate

Rule 3 explains how we have got away so far without explicit type
declarations—in their absence, everything defaults to @samp{int}. Let's
revisit our example again, here's `french2.pacc`_

@verbatim
Start :: int ← Yes → 1 / No → 0
Yes :: void ← "yes" / "oui"
No ← "non" / "no"
@end verbatim

The first rule @samp{Start} has type @samp{int}, this time we've made that
explicit. The second rule @samp{Yes} has type @samp{void}, again by explicit
declaration. The third rule @samp{No} has no explicit type, so by rule 2
its type is @samp{void}.

@cartouche
@quotation Warning
The type of an implicitly-typed rule depends on where it is in the grammar.
Rearranging rules can therefore change the meaning of a grammar!
@end quotation
@end cartouche

Arguably this is unfortunate (perhaps there should be a @samp{strict} mode
where every rule must have an explicit type?) but in practice most pacc
grammars have only a few different types, so implicit typing saves a lot of,
errm, typing.

Any C type that can be constructed with words and the @samp{*} character can be
used as a pacc type. This includes pointers, structures, and unions, but not
vectors (arrays) or function types. You could use a @samp{typedef} for those if
you really wanted to, and include it (directly or more likely by
@samp{#include}) in the pacc preamble.

@node Referencing the input
@section Referencing the input

@cindex reference

For our next example, let's consider how we could parse a decimal number. We'll
start by parsing a single digit, and we already know one way we could do that:

@verbatim
Digit ← "0" → 0 / "1" → 1 / "2" → 2 / "3" → 3 / "4" → 4 /
  "5" → 5 / "6" → 6 / "7" → 7 / "8" → 8 / "9" → 9
@end verbatim

This is tedious and error-prone, but it's the best we can do with the matchers
we've seen so far. Another matcher available in pacc is the @dfn{character
class}: square brackets enclose a set of characters to be matched, so the
character class @samp{[0123456789]} matches a decimal digit. To compress it
even further, we can write @samp{[0-9]}. The hyphen stands for all the
characters between the two characters it separates. But:

@verbatim
Digit <- [0-9] -> { /* what goes here? */ }
@end verbatim

@findex ref()
@findex ref_t
@findex ref_0()

Now that we have just one alternative that will match any digit, what
expression can we use that will give us the right value? We need some way to
refer back to input that we are matching. In any expression, you can write
@samp{ref()} which is a @dfn{reference} to whichever part of the input is
matched by the current rule. The type of @samp{ref()} is @samp{ref_t}, an
opaque type. A number of helper functions exist to do useful things with
@samp{ref_t} values. In this case, we can utilize the helper function
@samp{ref_0()} which returns the first byte of a @samp{ref_t} value.

@verbatim
Digit <- [0-9] -> { ref_0(ref()) - '0' }
@end verbatim

@node Operators
@section Operators

@cindex operators
@findex +
@findex ref_str()

So now we can concisely parse a single decimal digit: we match the digit with a
character class, and use a reference to the input to extract its value. To
extend this to decimal integers, we can use a @dfn{repetition operator}. Pacc
supports the repetition operators @samp{?}, @samp{*}, and @samp{+}, which have
the same meanings as they do in regular expressions. In this case, the correct
choice is @samp{+} which matches 1 or more occurences of the preceding matcher.

@verbatim
Decimal <- [0-9]+ -> { atoi(ref_str()) }
@end verbatim

We are using the @samp{ref_str()} function which returns a newly allocated, NUL
terminated string containing a copy of everything that the current rule
matches. And @samp{atoi()} is from @samp{<stdlib.h>} of course. (One snag with
this example is that pacc will happily match an arbitrarily long integer,
whereas @samp{atoi()} is limited to integers that will fit in an @samp{int},
but solving that issue is outside the scope of this tutorial. Possible options
might include the error-checking available in @samp{strtol()}, or to use an
arbitrary-precision integer package which provides its own conversion function,
for example @samp{gmp_sscanf}.)

The @samp{*} operator is similar to @samp{+}, but it can also match @emph{zero} occurences of its argument.

@node Binding values to names
@section Binding values to names

@cindex binding

expand example to do sums

@node Expressing precedence
@section Expressing precedence

@cindex precedence

add multiplication to example, discuss precedence

@node Handling whitespace
@section Handling whitespace

@cindex whitespace

expand example to include whitespace

@node Associativity
@section Associativity

@cindex associativity
@cindex left recursion

talk about associativity, left recursion, expand example to include - (assuming i actually know how to do that!)

@node Feeding example
@section Feeding example

@cindex feeding

turn sum example into a feedable one

@node Any matcher
@section Any matcher

@cindex any

sum example with C style comments

@node Using lookahead
@section Using lookahead

@cindex lookahead

When a PEG is parsing a symbol, it can ``look ahead'' as far in the
input as it needs to in order to decide what this symbol means. There's
a modest example of this in @file{pacc.pacc} itself.

You may have noticed that definitions in a pacc grammar are not terminated by a
@samp{;} semi-colon. You might have suspected that each definition must end
with a newline, but this is not the case. (I certainly recommend that you do,
in fact, end each definition with a newline, but this is for the benefit of any
humans reading the grammar, not pacc itself!)

So this is a perfectly good grammar, consisting of 3 definitions:

@verbatim
S ← yes {1} / no {0} yes ← "yes" / "oui" no ← "non" / "no"
@end verbatim

pacc can tell that the first @samp{yes} is a call to another rule, whereas the
second @samp{yes} is the definition of that rule, because of the @samp{←} that
comes after the second @samp{yes}. This is expressed in @samp{pacc.pacc} as
follows::

@verbatim
Rule5
     ← n:Name !lArrow !ColCol { s_text(call, n) }
     / ...
@end verbatim

In words, a bare Name is a call, only if it is @emph{not} followed by a left
arrow or a double colon. Otherwise, it starts a new definition; this will be
picked up by a different rule.

You might look at this example and think that pacc is looking just one token
ahead here, and an LALR(1) parser can do @emph{that}. But bear in mind that the
definition of @samp{Name} itself is expressed in this very same PEG, not in a
separate lexer. Effectively there are no tokens, only characters, and we are
already looking an arbitrary number of characters ahead.

In any case, although in this particular case the lookahead involves
(negative) assertions based on the relatively simple ``lexical'' rules
@samp{lArrow} and @samp{ColCol}, they could in general be as complicated as you
want. Positive assertions can also be used for lookahead, of course.

The miracle of packrat parsing means that, even in the face of this arbitrary
lookahead, the parser is @dfn{linear}, that is, @math{O(n)} for time and
space, where @emph{n} is the size of the input.


@node User Manual
@chapter User Manual

This @dfn{User Manual} is a complete but concise description of all the
features of pacc.

@menu
* Command line::
* Grammar::
* Lexical details::
* Binding::
* References to the input::
* Feeding::
* Calling the parser::
@end menu

@node Command line
@section Command line

@pindex pacc
@cindex command line
@cindex options
@cindex arguments
@cindex invoking @command{pacc}

Usage:

@example
pacc [@var{OPTION}]... @var{FILE}
@end example

@noindent
@command{pacc} must be invoked with the name of a grammar file, which
conventionally has a @file{.pacc} extension. @command{pacc} will write an
output file with the same name but a @file{.c} extension.

@noindent
Option summary:

@example
Operation modes
  -h, --help               display this help and exit
  -v, --version            report version number and exit
  -D, --dump-ast=@var{WHEN}      dump the parse tree at various points

Parser: 
  -n, --name=@var{NAME}          name the grammar (default: pacc)
  -f, --feed=@var{FILE}          write extra feed parser to @var{FILE}
  -r, --feed-rule=@var{RULE}     end-of-input rule when feeding (default: __)

Output:
  -d, --defines[=@var{FILE}]     also produce a header file
  -o, --output=@var{FILE}        write output to @var{FILE}
@end example

@cindex options, output
@cindex output options

@subsection Output options

Some options control the output of pacc.

@table @samp
@item --output=@var{FILE}
With the option @samp{-o@var{FILE}} or @samp{--output=@var{FILE}}, pacc will
write its output to the named @var{FILE}. Since pacc's output is C source code,
you probably want to specify a @var{FILE} with a @file{.c} extension.

@item --defines[=@var{FILE}]
With the option @samp{-d} or @samp{--defines}, pacc will additionally write a
header file, containing external definitions. If no @var{FILE} is specified,
the defines file will have the same name as the input file but with a @file{.h}
extension.
@end table

@cindex parser options
@cindex options, parser

@subsection Parser options

Some options control the parser (or parsers) that pacc generates.

@table @samp
@item --feed=@var{FILE}
With the option @samp{-f@var{FILE}} or @samp{--feed=@var{file}}, pacc writes an
extra @dfn{feed parser} to the named file. This can be used for parsing command
line input where some lines are correct but incomplete. If the main parser
returns an error, but the feed parser recognises the input, the controlling
program should solicit more input from the user, and feed it to the parser.

@item --feed-rule=@var{RULE}
Feeding requires a @var{RULE} to indicate places in the grammar where the end
of input is allowed to occur in a partial input. If feeding is enabled with
@samp{--feed=@var{FILE}}, but no @dfn{feed rule} is specified, the default feed
rule is @samp{__} (two underscores).
@end table

@subsection Help options

The usual help options are supported.

@table @samp
@item --help
If the @samp{-h} or @samp{--help} option is specified, pacc writes a short
description of its command line usage and options to standard output, then
exits.

@item --version
If the @samp{-v} or @samp{--version} option is specified, pacc writes version
information and its copyright statement to standard output, then exits.
@end table

@subsection Debug options

Some options can help with debugging pacc itself.

@table @samp
@item --dump-ast=@var{WHEN}
If the @samp{-D} or @samp{--dump-ast} option is specified, pacc will write a
dump of the Abstract Syntax Tree representation. The @var{WHEN} string
specifies various points at which the @abbr{AST} will be dumped: if it contains
the character @samp{0} the tree will be dumped as soon as the input grammar has
been parsed; @samp{1} dumps the tree after desugaring; @samp{2} dumps the tree
after @dfn{cooking} (preparing the grammar for feeding with the @samp{-f}
flag). Multiple dumps can be specified, e.g. @samp{-D02}.
@end table

@node Grammar
@section Grammar

The overall structure of a @dfn{pacc grammar} is very simple. First, there is
an optional preamble enclosed in braces: @samp{@{@}}. Then one or
more rules.

The @dfn{preamble} contains C source code, and is copied verbatim to the
beginning of pacc's output file. Typically it will comprise a few
@samp{#include} statements.

@subsection Rules

A @dfn{rule} consists of a name, an optional type, and a definition. The first
rule is the @dfn{start rule} of the grammar: valid utterances of the language
defined by the grammar match the start rule. 
 
The @dfn{name} follows the same lexical rules as C identifier names: it must
start with an alphabetic character or underscore, and remaining characters are
alphabetic, numeric, or underscores. The namespace of pacc rule names is
entirely separate from any C program, however, and there are no reserved words.

The @dfn{type}, if present, is introduced by a double colon @samp{::}, and can
be any C type name that is in scope, provided that name can be constructed with
identifiers and the @samp{*} character. Thus, @samp{struct} types are
supported, but function pointers are not. If the type is omitted, the rule has
the same type as the previous rule. (@strong{Caution}: this means that
rearranging the rules in a grammar can change the meaning of the grammar!) If
the first rule has no explicit type, its type is @samp{int}.
 
The @dfn{definition} is introduced with a left arrow @samp{<-}, which is
followed by one or more matchers, combined with operators.

@subsection Matchers

@dfn{Matcher}s are the fundamental building blocks of definitions.

@table @asis
@item Literal: @samp{"string"}
A string enclosed in double quotes matches exactly that string.

@item Character class: @samp{[a-z0-9]}
A series of characters in square brackets matches any single one of those
characters, which are written as in C, e.g. @samp{[\t\n]} matches a tab or a
newline. A character range is expressed using two characters separated by a
hyphen, and it matches any single character with a Unicode code point between
those of the two characters inclusive, e.g. @samp{[a-z]} matches any lower case
English letter. The character to the left of the hyphen must be strictly less
than the character to the right of the hyphen. A literal hyphen may be matched
by making it the first or last character in the class, e.g. @samp{[- _]}
matches a hyphen, a space, or an underscore. A literal right square bracket may
be matched by preceding it with a backslash, e.g.  @samp{[[\]]} matches a left
or right square bracket.

@item Call: @samp{rule_name}
A bare word names another rule---it is an error if there is no such rule
defined in this pacc grammar. It matches anything that the named rule matches.

@item Any: @samp{.}
The period character matches any single character. (UTF-8 coding is assumed.)
@end table

@subsection Operators

Pacc has the following @dfn{operators}, which are shown with their precedence,
in order from 5 to 0. In the descriptions that follow, @samp{e} and @samp{f}
are arbitrary pacc expressions; @samp{c} is an arbitrary C expression.

@table @asis
@item Parentheses: @samp{(e)} (5)
Parentheses are used for grouping.

@item Repetition: @samp{e?} @samp{e*} @samp{e+} (4)
@samp{e?} matches @samp{e} optionally (zero or one occurrences); @samp{e*}
matches zero or more repetitions of @samp{e}; and @samp{e+} matches one or more
repetitions of @samp{e}.

@item Guards: @samp{&e} @samp{!e} @samp{&@{c@}} (3)
@samp{&e} requires that the input matches @samp{e} at this point, but it does
not consume any input. @samp{!e} requires that the input does @emph{not} match
@samp{e}, and again does not consume anything. @samp{&@{ ... @}} is a
@dfn{semantic guard}: the braces hold an arbitrary C expression of type
@samp{int}. The expression is evaluated; the guard succeeds if its value is
non-zero.

@item Binding: @samp{name:e} (3)
Matches whatever @samp{e} matches, and binds the value of @samp{e} to
@samp{name}, which is then in scope till the end of this alternative, for use
in semantic guards and expressions. @xref{Binding}.

@item Bound literal: @samp{"string":e} (3)
Matches if @samp{e} matches and the value of @samp{e} (which must be of type
@samp{char *}) is equal to @samp{string}.

@item Sequencing: @samp{e f} (2)
Matches @samp{e} followed by @samp{f}.

@item Empty: @samp{%} (2)
Epsilon @samp{%} represents an empty sequence; it can always be omitted, but
its use can improve readability.

@item Value: @samp{-> @{c@}} (1)
Defines the @dfn{value} of a sequence; @samp{c} is an arbitrary C expression
which must have the same type as the rule. If @samp{c} is a name (C identifier
rules) or a decimal integer, the braces are optional. Otherwise, the arrow is
optional.

@item Alternation: @samp{e / f} (0)
If @samp{e} matches, the alternation matches; otherwise, if @samp{f} matches,
the alternation matches. Priority is important: @samp{e} is always tried before
@samp{f}.
@end table

@node Lexical details
@section Lexical details

@subsection Comments and whitespace

Whitespace between grammar elements is optional, except when needed to avoid
ambiguity. A @dfn{comment} may appear anywhere that whitespace can. Pacc
understands both styles of C comment: @samp{/* comment */} and @samp{// to end
of line} and also @samp{# to end of line}.

@subsection Alternative characters

@iftex
(Currently, the Unicode characters in the next few paragraphs are not visible
in this version of the documentation.)
@end iftex

The left arrow that separates a rule (and optional type) from its definition
can be written @samp{←} (U+2190 @sc{leftwards arrow}), or @samp{<-}
(@acronym{ASCII} less than, hyphen) or @samp{=} (@acronym{ASCII} equals).

The right arrow that separates a sequence from a value can be written @samp{→}
(U+2192 @sc{rightwards arrow}), or @samp{->} (@acronym{ASCII} hyphen, greater
than).

The slash that separates alternatives can be written @samp{/} (@acronym{ASCII}
slash) or @samp{|} (@acronym{ASCII} vertical bar).

The empty sequence can be represented with @samp{ε} (U+03B5 @sc{greek small
letter epsilon}) or @samp{%} (@acronym{ASCII} percent). (It can also be simply
omitted, although explicitly marking it aids readability.)

@node Binding
@section Binding

@cindex binding
@cindex variables
@findex :

The binding operator is @samp{:}. To its left is an identifier, following the
usual C rules. To its right is any pacc expression, which must match the input
at this point. The binding operator brings into scope the identifier on its
left; this name remains in scope till the end of the sequence, that is, either
the end of the rule or the next @samp{/} operator. This identifier may be used
in expressions and semantic guards.

If the expression on the right of the @samp{:} is a simple call, then the type
of the name bound is the same as the type of the rule called. In all other
cases, the type of the name bound is @samp{ref_t}; this includes the case where
the expression is a parenthesized call. For example, if there is a rule
@samp{Char :: char}, then after @samp{c:Char}, the type of @samp{c} is
@samp{char}, but after @samp{c:Char*} or @samp{c:(Char)} the type of @samp{c}
is @samp{ref_t}.

@node References to the input
@section References to the input

@cindex referring to the input
@cindex input, referring to

Expressions in a pacc grammar frequently need to refer to the input
string. The type @samp{ref_t} and a number of functions facilitate this.

@table @samp
@item ref_t
An opaque type which can hold a reference to a substring of the input string.
Whenever a name is bound to an expression that is not a simple rule call, it
has the type @samp{ref_t}. For example, in @samp{c:.}, the type of @samp{c} is
@samp{ref_t}.

@item ref_t ref()
Returns a reference to everything that is matched by the current rule.

@item char *ref_ptr(ref_t r)
Returns a pointer to the start of the substring referenced by @samp{r}.

@item char ref_0(ref_t r)
Returns the first byte of the substring referenced by @samp{r}.

@item size_t ref_len(ref_t r)
Returns the length of the substring referenced by @samp{r}.

@item char *ref_dup(ref_t r)
Returns a newly-allocated, NUL-terminated copy of the substring.  Almost
equivalent to @samp{strndup(ref_ptr(r), ref_len(r))}, except that it is more
portable, and it calls @samp{nomem()} if memory cannot be allocated.

@item char *ref_str()
Equivalent to @samp{ref_dup(ref())}.

@item int ref_cmp(ref_t r, char *s)
Has the same value as @samp{strcmp(ref_dup(r), s)}, but allocates no memory.
@end table

For example, here is how pacc's own parser used to recognise C identifiers, and
return them as normal C strings from the @samp{Name} rule (before pacc had
character classes).

@verbatim

  Name :: char *
    <- n:(NameStart NameCont*) _ { ref_dup(n) }

  NameStart :: void
    <- c:. &{ isalpha(ref_0(c)) || ref_0(c) == '_' }
  NameCont
    <- c:. &{ isalnum(ref_0(c)) || ref_0(c) == '_' }

@end verbatim

@node Feeding
@section Feeding

@cindex feeding
@cindex partial inputs
@cindex interactive streams
@findex -f, --feed
@findex -r, --feed-rule

Feeding is unique to pacc, and solves a problem with PEG parsing: if
the input is coming from an interactive stream, how do we know when to
prompt the user for more input? Note that since this is an interactive
stream, we need to give the user some idea that more input is needed,
for example the @env{PS2} prompt in the Bourne shell. (With a tokenized
LALR(1) parser, it is simple: when the parser asks the lexer for the
next token, it simply prompts the user for more input if it needs it.)

The approach taken by pacc is as follows. First, we need to identify
some @dfn{feed rule} that matches where a partial input may end. In a normal
interactive application, this rule will match @samp{"\n" *} (i.e. zero or
more occurences of the newline character). Conventionally, this rule is
named @samp{__} (two underscores), although another name can be given with
the @samp{-r} flag.

When pacc is invoked with the @samp{-f=FILE} option, it writes its normal
output as usual, then it writes an @emph{additional} parser to the specified
@samp{FILE} for a grammar which has been modified in the following ways:

@enumerate
@item
all semantic expressions have been removed;

@item
wherever a call to the feed rule occurs, the rule and the rest of the sequence
in which it occurs are optional.
@end enumerate

For example, consider this trivial grammar, which sums two digits,
possibly on separate lines.

@verbatim
  Sum :: int <- a:Digit __ b:Digit "\n" { a + b }
  Digit <- [0-9] { *ref_ptr(ref()) - '0' }
  __ <- "\n" *
@end verbatim

In the extra parser generated when feeding is enabled, the first line
will effectively be this:

@verbatim
  Sum :: int <- a:Digit (__ b:Digit "\n" / %)
@end verbatim

@node Calling the parser
@section Calling the parser

@cindex calling the parser
@cindex invoking the parser
@cindex parser, invoking

For a parser with a return type of @samp{result}, the external functions
available (and defined in header file written with the @samp{-d} flag) will
look approximately like this:

@verbatim
struct pacc_parser;
extern int pacc_trace;
extern struct pacc_parser *pacc_new(void);
extern void pacc_input(struct pacc_parser *, char *input, size_t length);
extern void pacc_destroy(struct pacc_parser *);
extern int pacc_parse(struct pacc_parser *);
extern result pacc_result(struct pacc_parser *);
extern char *pacc_error(struct pacc_parser *);
extern char *pacc_pos(struct pacc_parser *, const char *);
extern int pacc_wrap(const char *, char *, size_t, result *result);
@end verbatim

The interface is an Object-Oriented one:

@table @samp
@item pacc_new()
returns a new parser object.
@item pacc_input()
prepares the parser to parse the given @samp{input} of given @samp{length}.
@item pacc_parse()
performs the parse, returning @samp{1} if it was successful, @samp{0}
otherwise.
@item pacc_error()
if @samp{pacc_parse()} returned @samp{0}, returns a newly-allocated string describing the error that the parser found.
@item pacc_result()
if @samp{pacc_parse()} returned @samp{1}, returns the result of the parse.
@item pacc_destroy()
destroys the parser.
@item pacc_wrap()
is a convenience function that creates a parser, invokes it on the given input,
destroys the parser and returns @samp{0} if the input could not be parsed,
otherwise evaluates the result of the parse into @samp{result_pointer},
destroys the parser and returns @samp{1}.
@end table

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@include fdl.texi

@node Index
@unnumbered Index

@printindex cp

@bye
