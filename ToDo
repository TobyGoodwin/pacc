Error handling

    This needs more experience. Currently, the merging of errors
    destroys more information than I'm happy with.  Also, need to get
    line numbers. One possibility is to count newlines after an error
    has been encountered; another is to maintain a line counter as we
    currently maintain col, incrementing it if "any" matches a newline
    and by the newline count in every matched literal.

Complete the command-line interface

    Need --help for one. And --defines (write a .h file), although I'm
    inclined to think that that should be the default. And for the
    partialization hack: --feeder to specify the function that extends a
    line (if that's the interface we want); --feed-rule to specify what
    the rule that matches end-of-line is called; if we have defaults for
    both of these, --feed to turn on feeding.

Detect (and handle?) left recursion

    Piumarta does this by analyzing the tree. We will need to copy this,
    perhaps as part of desugaring or optimizing. Other things include:
    checking that every rule is reached; checking that non-void rules
    always return a value (and that void rules never do).

Optimize

    First for space - this is ongoing with hashing, and eval list stuff.
    Then (and we will need some more test cases) for time.

Revisit match() versus bra/ket versus auto-typing

    This can be independent of the eval stack stuff, 'cos we need two
    lists (for long call_or_expr and off_t column) anyway.

Parser optimization / manipulation (including partialization hack)

Value inheritance

    In your rule "SeqRule ← s:Sequence → s / u:UnaryRule → u" would not
    "SeqRule ← Sequence / UnaryRule" do as well, if not better?

Make the test scaffold better

    It's still several button presses to run both sets of tests. This is
    nearly done, but the two harnesses still need to be completely
    pushed together.

Many many cleanups (XXX)

Recognise comments in raw code

Use C style comments in .pacc files

Generate #line directives

Review of the parsing engine - do we really need so many stacks?

Autoconfiscation

Only one instance of each type per union

Handle void types

Dynamically allocate everything

UTF-8 support

Documentation
