Source Files
============

Since pacc is partly written by pacc, it can all get a bit confusing!

emit.c - writes the output file from the AST

main.c - command line parsing, other glue

pacc.c - the packrat parser that constructs an AST from a .peg file;
constructed (by pacc) from pacc.peg

paccman.c - constructs an AST manually for bootstrapping

pacc.peg - the grammar description that is converted to pacc.c

syntax.c - support for the Abstract Syntax Tree constructed as the
grammar is read


Other Notes
===========

The key to (linear) packrat parsing is the memoization table that
squirrels away every result that the parser discovers about the input as
it is read. In a naive implementation, this is simply a matrix, with one
row for each rule of the grammar, and one column for each character of
the input. However, this matrix is (typically) very sparse, so pacc
tries to do better.

thoughts...

rows is of the order of 100 - it would be a pretty zany grammar that had
more than 1000 rules = ~7 bits

columns is of the order of 100000 - we should support inputs of 1
megabyte (or 10 or even 100 if possible), but most inputs will be *much*
smaller than that = ~16 bits

(should we consider swapping the memoization table ourselves, like sam?
or just bung it all in vm and hope for the best?)

so, thinking about a hash function for the matrix, we have about 23
bits of input, in two integers. that should be enough to do something
interesting...

---

Insight: we talk about semantic *actions*, and in ``yacc`` they are ``C``
program fragments, but really those things are expressions! In ``yacc``,
of course, the convention is that the program fragment delivers a value
by assigning to ``$$``. So these things are not really actions at all, but
*expressions*. They have values, and types.

How might we express this?

int Decimal <- d:'0' / d:'1' / ... { d - '0' }
int Decimal <- < [0-9] > { d - '0' } ???
struct Node *cmd <- ...
                 /  TWIDDLE optcaret s:word p:words { mk(nMatch, s, p) }
                 / ... 

Problems: braces around expressions look wrong... didn't Ford have a
different / better syntax? OK, all sorts of stuff coming out here (I
don't like Piumarta's < > syntax; ...). However, the idea of typing each
rule seems plausible. And the type of the first rule can become the
default type.

---

2009-06-17

Pressing on with semantic expressions. Each rule has a type (worry about
defaulting later).

Rules of type "void" never yield a value, of course. Should we allow
expressions that are evaluated for their side effects? I guess so.
Clearly it is not legal to bind a name to a "void" rule.

Rules of most other types are fine: the semantic expression must yield a
value of the given type:

  int Additive <- m:Multitive '+' a:Additive { m + a }

But we need at least something else: a way to extract parts of the input
text. A rule of type [ haven't decided: either "char *", or some special
type like "text" ] has a default value (in the absence of a semantic
expression) of [ haven't decided: either the entire text matched by the
rule, or the concatenation of the parts of it that aren't matched by a
"void" call, or ... ]. This default value is freshly allocated by a call
to realloc() - to use your own memory allocator, simply #define realloc
in the raw code at the top of the file.

And the first decision is instantly made: since this is only a default,
certainly we should use "char *", and not something special. Hmm... 

  char *Name <- Letter LetterOrDigit*

The value is the text matched. We've said that in general a missing
expression is an error, unless the only thing happening here is a call,
in which case the value is simply propagated. So that normally

  A <- B

means

  A <- b:B -> b

But these two defaults can collide. In this grammar:

  char *Name <- NamePlus
  char *NamePlus <- l:Letter LetterOrDigit* -> l

does Name get the value of all the text it matches, or the value of the
solitary call? Ways out: 1) introduce "text" and say that solitary call
is indeed the default for all types except "text", which otherwise
behaves identically to "char *". 2) Say that, for "char *" only, matched
text beats solitary call: write "char *Name <- np:NamePlus -> np" when
that's what you want. 3) Do away with one of the defaults altogether:
3a) just say that solitary call is not a default; 3b) say that we use
Piumarta-style bra kets to mark the matched text. 4) Provide a function
/ macro that means "all the matched text".

I don't like any of these!
