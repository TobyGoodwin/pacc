{

#include <ctype.h>

#include "syntax.h"

}

Grammar :: struct s_node *
    ← _ p:Preamble ds:Defns End → 
    { s_both(grammar, "yy", cons(p, ds)) }

Defns
    ← d:Defn ds:Defns { cons(d, ds) }
    / ε { 0 }

Defn
    ← n:Name t:TypeOptional lArrow r:Rule _ →
	{ s_both(rule, n, cons(s_text(type, t), r)) }

Rule
    ← s:SeqRule Slash r:Rule { s_alt(s, r) /* x y */ }
    / s:SeqRule → s

SeqRule
    ← s:Sequence → s
    / u:UnaryRule → u

UnaryRule
    ← p:PrimRule Query { s_both(rep, ",1", p) }
    / p:PrimRule Star { s_both(rep, 0, p) }
    / p:PrimRule Plus { s_both(rep, "1,", p) }
    / p:PrimRule → p

PrimRule
    ← n:Name { s_text(call, n) } !lArrow !ColCol
    / Dot { s_new(any) }
    / l:StringLit { s_text(lit, l) }
    / lParen r:Rule rParen → r

Sequence
    ← m:Matchers { s_kid(seq, m) }

Matchers
    ← m:Matcher ms:Matchers { cons(m, ms) }
    / m:Matcher → m

Matcher
    ← Epsilon { s_new(seq) }
    / r:Result → r
    / And u:UnaryRule { s_kid(and, u) }
    / Not u:UnaryRule { s_kid(not, u) }
    / And c:Code { s_retype(guard, c) }
    / n:Name Colon u:UnaryRule { s_both(bind, n, u) }
    / u:UnaryRule → u

Result
    ← rArrow n:Name { s_both(expr, n, s_text(ident, n)) }
    / rArrow? c:Code → c

CodeNames
    ← n:Name ns:CodeNames { s_set_cons(s_text(ident, n), ns) }
    / StringLit ns:CodeNames → ns
    / CharLit ns:CodeNames → ns
    / c:Char &{ ref_0(c) != '}' } ns:CodeNames → ns
    / ε { 0 }

CodeAndNames
    ← n:CodeNames { s_both(expr, ref_str(), n) }

Code
    ← "{" n:CodeAndNames "}" _ → n

# XXX this is just c:Code?, except that we don't yet generate "0" for
# missing options.
Preamble
    ← c:Code { s_retype(preamble, c) }
    / ε { s_text(preamble, 0) }

Name :: char *
    ← n:(NameStart NameCont*) _ { ref_dup(n) }

TypeOptional
    ← ColCol TypeElement+ { s_stash_type(ref_str()) }
    / ε { s_stashed_type() }

StringLit ← "\"" q:QuotedChars "\"" _ → q

QuotedChars ← (!"\"" QuotedChar)* { ref_str() }

Char :: ref_t
    ← . { ref() }

CharLit :: void
    ← "'" QuotedChar "'" _

QuotedChar
    ← "\\n" / "\\t" / "\\\\" / "\\\"" / !"\\" Char

NameStart
    ← c:Char &{ isalpha(ref_0(c)) || ref_0(c) == '_' }

NameCont
    ← c:Char &{ isalnum(ref_0(c)) || ref_0(c) == '_' }

TypeElement
    ← Name _ / "*" _

Comment
    ← "#" (c:Char &{ ref_0(c) != '\n' })* "\n"

_
    ← (" " / "\t" / "\n" / Comment) *

And ← "&" _
lArrow  ← ("←" / "<-") _
rArrow  ← ("→" / "->") _
Colon ← ":" _
ColCol ← "::" _
Dot ← "." _
Epsilon ← "ε" _
Not ← "!" _
lParen ← "(" _
rParen ← ")" _
Plus ← "+" _
Query ← "?" _
Slash ← "/" _
Star ← "*" _

End ← !.
