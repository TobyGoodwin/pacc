{

#include <ctype.h>

#include "syntax.h"

}

Grammar :: struct s_node *
    ← _ p:Preamble ds:Defns End → 
    { s_both(grammar, "yy", cons(p, ds)) }

Defns
    ← d:Defn ds:Defns { cons(d, ds) }
    / ε { 0 }

Defn
    ← n:Name t:TypeOptional lArrow r:Rule0 _ →
	{ s_both(rule, n, cons(s_text(type, t), r)) }

Rule0
    ← s:Rule1 Slash r:Rule0 { s_alt(s, r) }
    / s:Rule1 → s

Rule1 
    ← Epsilon r:Result? → { s_kid(seq, r) }
    / s:Rule2 r:Result? → { s_kid(seq, append(s, r)) }

Rule2
    ← r:Rule3 s:Rule2 { cons(r, s) }
    / ε { 0 }

Rule3
    ← And u:Rule4 { s_kid(and, u) }
    / Not u:Rule4 { s_kid(not, u) }
    / And c:Code { s_retype(guard, c) }
    / n:Name Colon u:Rule4 { s_both(bind, n, u) }
    / l:StringLit Colon u:Rule4 { s_both(lit, l, u) }
    / u:Rule4 → u

Rule4
    ← r:Rule5 Query { s_both(rep, ",1", r) }
    / r:Rule5 Star { s_both(rep, 0, r) }
    / r:Rule5 Plus { s_both(rep, "1,", r) }
    / r:Rule5 → r

Rule5
    ← n:Name !lArrow !ColCol { s_text(call, n) }
    / Dot { s_new(any) }
    / l:StringLit { s_text(lit, l) }
    / c:CClass → c
    / r:Rule6 → r

Rule6
    ← lParen r:Rule0 rParen → r

# XXX All sorts of problems here: we don't handle negated character
# classes, there's no way to include "]" in a character class, we don't
# handle \n, or any more elaborate escapes.
CClass
    ← "[" c:CRanges "]" _ { s_both(cclass, 0, c) }

CRanges
    ← c:CRange cs:CRanges { append(c, cs) }
    / ε { 0 }

CRange
    ← ! "]" a:. ! "-" { s_range1(ref_dup(a)) }
    / ! "]" a:. "-" b:. { s_range2(ref_dup(a), ref_dup(b)) }

Result
    ← rArrow n:Name { s_both(expr, n, s_text(ident, n)) }
    / rArrow? c:Code → c

CodeNames
    ← n:Name ns:CodeNames { s_set_cons(s_text(ident, n), ns) }
    / StringLit ns:CodeNames → ns
    / CharLit ns:CodeNames → ns
    / C_Comment ns:CodeNames → ns 
    / (!"}" .) ns:CodeNames → ns
    / ε { 0 }

CodeAndNames
    ← n:CodeNames { s_both(expr, ref_str(), n) }

Code
    ← "{" n:CodeAndNames "}" _ → n

# XXX unfortunately, we assume that there is always a preamble node,
# even if there is no preamble. We could say
# Preamble
#     ← c:Code? { c ? s_retype(preamble, c) : s_text(preamble, 0) }
# but that doesn't seem like an improvement.
Preamble
    ← c:Code { s_retype(preamble, c) }
    / ε { s_text(preamble, 0) }

Name :: char *
    ← n:(NameStart NameCont*) _ { ref_dup(n) }

TypeOptional
    ← ColCol TypeElement+ { s_stash_type(ref_str()) }
    / ε { s_stashed_type() }

StringLit ← "\"" q:QuotedChars "\"" _ → q

QuotedChars ← (!"\"" QuotedChar)* { ref_str() }

CharLit :: void
    ← "'" QuotedChar "'" _

# XXX this needs to completely match the C:1999 definition, including
# octal, hex and universal escapes. 
QuotedChar
    ← SimpleCharEscape
    / !"\\" .

SimpleCharEscape
    ← "\\\'" / "\\\"" / "\\\?" / "\\\\"
    / "\\a" / "\\b" / "\\f" / "\\n" / "\\r" / "\\t" / "\\v"

NameStart
    ← c:. &{ isalpha(ref_0(c)) || ref_0(c) == '_' }

NameCont
    ← c:. &{ isalnum(ref_0(c)) || ref_0(c) == '_' }

TypeElement
    ← Name _ / "*" _

Comment
    ← "#" (!"\n" .)* "\n"
    / C_Comment

C_Comment
    ← "//" (!"\n" .)* "\n"
    / "/*" (!"*/" .)* "*/"

_
    ← (" " / "\t" / "\n" / Comment) *

And ← "&" _
lArrow  ← ("←" / "<-" / "=") _
rArrow  ← ("→" / "->") _
Colon ← ":" _
ColCol ← "::" _
Dot ← "." _
Epsilon ← "ε" _
Not ← "!" _
lParen ← "(" _
rParen ← ")" _
Plus ← "+" _
Query ← "?" _
Slash ← "/" _
Star ← "*" _

End ← !.
