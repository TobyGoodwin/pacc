/*
vim: syntax=c
This file is processed by template.sh to produce template.c. Therefore,
it has the syntax of a C program, but is not to be so handled by, for
instance, "make".
*/

#undef NDEBUG

#include <assert.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define Tracing 0
#define Trace if (Tracing)
#define Instr if (0)

static void panic(const char *e) {
    fprintf(stderr, "pacc: panic: %s\n", e);
    exit(1);
}

static void nomem(void) {
    panic("out of memory");
}

enum status {
    no_parse, parsed, evaluated, uncomputed
};

/* XXX probably want to reconsider this; see Journal 2010-02-10 */
typedef off_t *ref_t;

#EMIT_DECLARATIONS

struct intermed {
    /* Where in the matrix are we? Note that the bottom two bits of rule
     * also encode a status. */
    long rule; off_t col;
    off_t remainder; /* unparsed string */
    long expr_id; /* id of the expression to evaluate, yielding... */
    union YY_union value; /* ... the semantic value XXX needs to use g_name */
    struct {
	long call_id; /* a call */
	off_t col; /* a column */
    } *evlis;
    size_t ev_alloc;
    size_t ev_valid;
};

static struct intermed *cur;

static void _pacc_save_core(long c, off_t col) {
    Trace fprintf(stderr, "_pacc_save_core(%ld, %ld)\n", c, col);
    if (cur->ev_valid == cur->ev_alloc) {
	cur->ev_alloc = cur->ev_alloc * 2 + 1;
	cur->evlis = realloc(cur->evlis, cur->ev_alloc * sizeof(*cur->evlis));
	if (!cur->evlis) nomem();
    }
    cur->evlis[cur->ev_valid].call_id = c;
    cur->evlis[cur->ev_valid].col = col;
    ++cur->ev_valid;
}

/* a pacc parser */
struct pacc_parser {
    char *name;
    char *string;
    off_t input_length;
    struct intermed **m_bkt;
    unsigned int m_bkt_cnt;
    unsigned char *m_valid;
    unsigned char m_chain_max;
    
    unsigned char *stack; /* the stack */
    unsigned char *sp; /* next slot in stack */
    unsigned char *stack_alloc; /* last slot in stack */

    /* A dynamic array of error strings */
    char **err;
    size_t err_alloc;
    size_t err_valid;
    /* The highest column to have associated error */
    off_t err_col;
};

static void _pacc_push(void *x, size_t s, struct pacc_parser *p) {
    if (p->sp + s >= p->stack_alloc) {
	size_t l = 2 * (p->stack_alloc - p->stack) + s;
	unsigned char *n = realloc(p->stack, l);
	if (!n) nomem();
	p->sp = n + (p->sp - p->stack);
	p->stack = n;
	p->stack_alloc = n + l + 1;
    }
    assert(p->sp >= p->stack && p->sp + s < p->stack_alloc);
    memcpy(p->sp, x, s);
    p->sp += s;
}

#define _pacc_Push(v) _pacc_push(&(v), sizeof (v), _pacc)

static void *_pacc_pop(size_t s, struct pacc_parser *p) {
    assert(p->sp - s >= p->stack);
    p->sp -= s;
    return p->sp;
}

#define _pacc_Pop(v) memcpy(&(v), _pacc_pop(sizeof (v), _pacc), sizeof (v))
#define _pacc_Discard(v) ((void)_pacc_pop(sizeof (v), _pacc))

#define ref() (&cur->col)
#define ref_0(a) (_pacc->string[*a])
#define ref_cmp(a, s) (_pacc_ref_cmp((a), (s), _pacc))
#define ref_dup(a) (_pacc_ref_dup((a), _pacc))
#define ref_len(a) ((a)[1] - (a)[0])
#define ref_ptr(a) (_pacc->string + *(a))
#define ref_str() (_pacc_ref_dup(ref(), _pacc))
#define ref_streq(a, b) (_pacc_ref_streq((a), (b), _pacc))

static char *_pacc_ref_dup(ref_t a, struct pacc_parser *p) {
    char *r;
    off_t l;

    l = a[1] - a[0];
    r = realloc(0, l + 1); if (!r) nomem();
    strncpy(r, p->string + a[0], l);
    r[l] = '\0';
    return r;
}

static int _pacc_ref_streq(ref_t a, char *b, struct pacc_parser *p) {
    /* XXX this could be made quicker */
    if (strlen(b) != (size_t)(a[1] - a[0])) return 0;
    return strncmp(p->string + a[0], b, a[1] - a[0]) == 0; 
}

/* Find the largest available prime which is smaller than the target
 * bucket count. This exponential selection of primes was generated by
 * Dan Bernstein's primegen-0.97 package, using the following:

perl -le '$x=1;while(($e=int(exp($x/1)))<2**32){print "./primes ",$e," ",100+$e," | sed 1q";++$x}' | sh

 * except that I replaced 2 with 3.
 */
static void _pacc_set_bkt_cnt(struct pacc_parser *p) {
    static unsigned int primes[] = {
	3, 7, 23, 59, 149, 409, 1097, 2999, 8111, 22027, 59879, 162779, 442439,
	1202609, 3269029, 8886113, 24154957, 65659969, 178482319, 485165237,
	1318815761, 3584912873U
    };
    int i, p_sz = sizeof(primes) / sizeof(*primes);
    unsigned long bkt_cnt = n_rules * (p->input_length + 1) / 100;

    for (i = 1; i < p_sz; ++i) {
	if (primes[i] > bkt_cnt) break;
    }
    p->m_bkt_cnt = primes[i - 1];
}

static struct pacc_parser *YY_new(void) {
    struct pacc_parser *p;

    p = realloc(0, sizeof *p);
    if (!p) nomem();
    p->m_chain_max = 0;
    p->sp = 0;
    p->stack = p->stack_alloc = 0;
    p->err = 0;
    p->err_alloc = 0;
    p->err_valid = 0;
    return p;
}

static void YY_input(struct pacc_parser *p, char *n, char *s, off_t l) {
    unsigned int i;

    p->name = n;
    p->string = s;
    p->input_length = l;
    _pacc_set_bkt_cnt(p);
    p->m_bkt = realloc(0, sizeof(struct intermed *) * p->m_bkt_cnt);
    if (!p->m_bkt) nomem();
    p->m_valid = realloc(0, 2 * p->m_bkt_cnt);
    for (i = 0; i < p->m_bkt_cnt; ++i) {
	p->m_bkt[i] = 0;
	p->m_valid[i * 2] = 0; /* valid */
	p->m_valid[i * 2 + 1] = 0; /* allocated */
    }
}

static void pacc_parser_destroy(struct pacc_parser *p) {
    free(p);
}

/* hash chains */
static struct intermed *_pacc_result(struct pacc_parser *p, off_t col, long rule) {
    unsigned char i;
    unsigned int h;
    struct intermed *bkt, *r;

    assert(col < p->input_length + 1);
    Trace fprintf(stderr, "_pacc_result(%ld, %ld)\n", col, rule);
    h = (col + (rule << 6) + (rule << 16) - rule) % p->m_bkt_cnt;
    bkt = p->m_bkt[h];
    for (i = 0; i < p->m_valid[h * 2]; ++i) {
	r = bkt + i;
	if (r->col == col && r->rule >> 4 == rule)
	    return r;
    }
    if (i == p->m_valid[h * 2 + 1]) {
	if (i == 255) panic("bucket too large");
	if (i + 1 > p->m_chain_max) p->m_chain_max = i + 1;
	p->m_bkt[h] = bkt = realloc(bkt, p->m_chain_max * sizeof(struct intermed));
	if (!bkt) nomem();
	p->m_valid[h * 2 + 1] = p->m_chain_max;
    }
    r = bkt + i;
    /* Initialize the new element. */
    r->col = col; r->rule = rule << 4 | uncomputed;
    r->evlis = 0;
    r->ev_alloc = r->ev_valid = 0;
    /* Correct use of a side effect in an (unfailing) assert. */
    assert((r->expr_id = 0) == 0);
    ++(p->m_valid[h * 2]);
    return r;
}

static void error(struct pacc_parser *_pacc, char *what, off_t col) {
    int doit, append;
//Trace fprintf(stderr, "error(Grammar, 0) at col %ld\n", col);
    append = doit = 1;
    if (col > _pacc->err_col) append = 0;
    else if (col == _pacc->err_col) {
        size_t i;
        for (i = 0; i < _pacc->err_valid; ++i) {
            if (strcmp(_pacc->err[i], what) == 0) doit = 0;
        }
    } else doit = 0;
    if (doit) {
        if (append) ++_pacc->err_valid;
        else _pacc->err_valid = 1;
        if (_pacc->err_valid > _pacc->err_alloc) {
            _pacc->err_alloc = 2 * _pacc->err_alloc + 1;
            _pacc->err = realloc(_pacc->err, _pacc->err_alloc * sizeof(char *));
            if (!_pacc->err) nomem();
        }
        _pacc->err[_pacc->err_valid - 1] = what;
        _pacc->err_col = col;
    }
}

/* Given a parser p, and a column col, return the "coordinates" in a
 * newly allocated pair of ints.  coord[0] is the line number, and
 * coord[1] is the column within the line.  XXX till this isn't
 * memoized, we're no longer linear. */
static int *_pacc_coords(struct pacc_parser *p, off_t col) {
    int c, nl, start, *coords;

    coords = realloc(0, 2 * sizeof(int)); if (!coords) nomem();
    nl = 1; /* line numbering is 1-based, natch */
    start = 0;
    for (c = 0; c < col; ++c) {
	if (p->string[c] == '\n') {
	    ++nl;
	    start = c;
	}
    }
    coords[0] = nl;
    /* as is column numbering */
    coords[1] = 1 + c - start;
    return coords;
}
/* The userland version */
#define pacc_coords _pacc_coords(_pacc, col)

static int engine(struct pacc_parser *_pacc, PACC_TYPE *result) {
    enum status status;
    int cont, st;
    off_t col, rule_col;
    int evaluating;
    struct intermed *last;
    col = 0;
    cont = -1;
    evaluating = 0;
    size_t pos, _pacc_ev_i;

#EMIT_ENGINE

    col = 0;
    cur = _pacc_result(_pacc, col, start_rule_id);
    if (parsed && !evaluating && (cur->rule & 3) == parsed) {
	unsigned char *stack_save;

	Trace fprintf(stderr, "PARSED! Time to start eval...\n");
	evaluating = 1;
	_pacc_ev_i = 0;
    eval_loop:
	Trace fprintf(stderr, "eval loop with _pacc_ev_i == %ld\n", _pacc_ev_i);
	stack_save = _pacc->sp;
    eval1:
	while (_pacc_ev_i < cur->ev_valid) {
	    int col, rule;
	    rule = cur->evlis[_pacc_ev_i].call_id;
	    col = cur->evlis[_pacc_ev_i].col;
	    ++_pacc_ev_i;
	    Trace fprintf(stderr, "eval loop: r%d @ c%d\n", rule, col);
	    _pacc_Push(cur);
	    _pacc_Push(_pacc_ev_i);
	    cur = _pacc_result(_pacc, col, rule);
	    _pacc_ev_i = 0;
	}
	if ((cur->rule & 3) != evaluated && cur->expr_id) {
	    st = cur->expr_id;
	    col = cur->col;
	    goto top;
	}
    _pacc_expr_done:
	cur->rule = (cur->rule & ~3) | evaluated;
	if (_pacc->sp != stack_save) {
	    _pacc_Pop(_pacc_ev_i);
	    _pacc_Pop(cur);
	    goto eval1;
	}
	Trace fprintf(stderr, "eval finished\n");
	goto contin;
    }

    Instr {
	unsigned char min;
	unsigned int i;
	unsigned long a, v;

	a = v = 0;
	min = _pacc->m_chain_max;
	for (i = 0; i < _pacc->m_bkt_cnt; ++i) {
	    unsigned char valid = _pacc->m_valid[i * 2];
	    unsigned char alloc = _pacc->m_valid[i * 2 + 1];
	    fprintf(stderr, "%d/%d ", valid, alloc);
	    v += valid; a += alloc;
	    if (alloc < min)
		min = alloc;
	}
	fprintf(stderr, "\n");
	fprintf(stderr, "used %u buckets\n", _pacc->m_bkt_cnt);
	fprintf(stderr, "chain length from %d to %d\n", min, _pacc->m_chain_max);
	fprintf(stderr, "total used/allocated: %ld/%ld\n", v, a);
    }
    if ((cur->rule & 3) == evaluated) {
	Trace fprintf(stderr, "parsed with value " TYPE_PRINTF "\n", cur->value.u0); /* XXX u0 */
	*result = cur->value.u0;
    } else if ((cur->rule & 3) == parsed) {
	Trace fprintf(stderr, "parsed with void value\n");
    } else Trace fprintf(stderr, "not parsed\n");
    return (cur->rule & 3) == evaluated;

contin:
    Trace fprintf(stderr, "continuing in state %d\n", cont);
    st = cont;
    goto top;
}

static void _pacc_error(struct pacc_parser *p) {
    int *coords;
    size_t i;

    coords = _pacc_coords(p, p->err_col);
    printf("%s:%d:%d: ", p->name, coords[0], coords[1]);

    /* XXX this, or something like it, is very handy, and needs to go
     * in. But we're holding off for now as all failing test cases would
     * need to be changed. */
    //printf("got `%c', ", p->string[p->err_col]); /* XXX UTF-8? */

    printf("expected ");
    for (i = 0; i < p->err_valid; ++i) {
	char *s;
	for (s = p->err[i]; *s; ++s) {
	    if (isprint(*s)) putchar(*s);
	    else switch (*s) {
		case '\n':
		    puts("\\n");
		    break;
		default:
		    printf("\\x%02x", *s);
		    break;
	    }
	}

	if (i + 1 < p->err_valid) {
	    printf(", ");
	    if (i + 2 == p->err_valid) printf("or ");
	}
    }
    printf("\n");
    //printf("(column %ld)\n", _pacc->err_col);
}

int YY_parse(char *name, char *addr, off_t l, PACC_TYPE *result) {
    int parsed;
    struct pacc_parser *p;

    /* XXX the result should live in the pacc_parser */

    p = YY_new();
    YY_input(p, name, addr, l);

    parsed = engine(p, result);

    if (!parsed) _pacc_error(p);

    pacc_parser_destroy(p);

    return parsed;
}
