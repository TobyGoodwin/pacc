/*
vim: syntax=c
This file is processed by template.sh to produce template.c. Therefore,
it has the syntax of a C program, but is not to be so handled by, for
instance, "make".
*/

#undef NDEBUG

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define Tracing 0
#define Trace if (Tracing)
#define Instr if (0)

static void panic(const char *e) {
    fprintf(stderr, "pacc: panic: %s\n", e);
    exit(1);
}

static void nomem(void) {
    panic("out of memory");
}

enum status {
    no_parse, parsed, evaluated, uncomputed
};

/* A dynamic array of error strings */
char **_pacc_err = 0;
size_t _pacc_err_alloc = 0;
size_t _pacc_err_valid = 0;
off_t _pacc_err_col;

/* XXX probably want to reconsider this; see Journal 2010-02-10 */
typedef off_t *ref_t;

#EMIT_DECLARATIONS

struct intermed {
    /* Where in the matrix are we? Note that the bottom two bits of rule
     * also encode a status. */
    long rule; off_t col;
    off_t remainder; /* unparsed string */
    long expr_id; /* id of the expression to evaluate, yielding... */
    union yy_union value; /* ... the semantic value XXX needs to use g_name */
    struct {
	long call_id; /* a call */
	off_t col; /* a column */
    } *evlis;
    size_t ev_alloc;
    size_t ev_valid;
};

static struct intermed *cur;

static void _pacc_save_core(long c, off_t col) {
    Trace fprintf(stderr, "_pacc_save_core(%ld, %ld)\n", c, col);
    if (cur->ev_valid == cur->ev_alloc) {
	cur->ev_alloc = cur->ev_alloc * 2 + 1;
	cur->evlis = realloc(cur->evlis, cur->ev_alloc * sizeof(*cur->evlis));
	if (!cur->evlis) nomem();
    }
    cur->evlis[cur->ev_valid].call_id = c;
    cur->evlis[cur->ev_valid].col = col;
    ++cur->ev_valid;
}

/* a pacc parser */
struct _pacc_parser {
    char *string;
    off_t input_length;
    struct intermed **m_bkt;
    unsigned int m_bkt_cnt;
    unsigned char *m_valid;
    unsigned char m_chain_max;
    // this is not needed!
    //union _pacc_stackable *cont_st; /* the stack */
    char *cont_st;
    char *cont_p; /* next slot in cont_st */
    char *cont_alloc; /* last slot in cont_st */

};

static void _pacc_push(void *x, size_t s, struct _pacc_parser *p) {
    if (p->cont_p + s >= p->cont_alloc) {
	int l = 2 * (p->cont_alloc - p->cont_st) + s;
	char *n = realloc(p->cont_st, l);
	if (!n) nomem();
	p->cont_p = n + (p->cont_p - p->cont_st);
	p->cont_st = n;
	p->cont_alloc = n + l + 1;
    }
    assert(p->cont_p >= p->cont_st && p->cont_p + s < p->cont_alloc);
    memcpy(p->cont_p, x, s);
    p->cont_p += s;
}

#define _pacc_Push(v) _pacc_push(&(v), sizeof (v), _pacc)

static void *_pacc_pop(size_t s, struct _pacc_parser *p) {
    assert(p->cont_p - s >= p->cont_st);
    p->cont_p -= s;
    return p->cont_p;
}

#define _pacc_Pop(v) memcpy(&(v), _pacc_pop(sizeof (v), _pacc), sizeof (v))
#define _pacc_Discard(v) ((void)_pacc_pop(sizeof (v), _pacc))

#define ref() (&cur->col)
#define ref_0(a) (_pacc->string[*a])
#define ref_cmp(a, s) (_pacc_ref_cmp((a), (s), _pacc))
#define ref_dup(a) (_pacc_ref_dup((a), _pacc))
#define ref_len(a) ((a)[1] - (a)[0])
#define ref_ptr(a) (_pacc->string + *(a))
#define ref_str() (_pacc_ref_dup(ref(), _pacc))
#define ref_streq(a, b) (_pacc_ref_streq((a), (b), _pacc))

char *_pacc_ref_dup(ref_t a, struct _pacc_parser *p) {
    char *r;
    off_t l;

    l = a[1] - a[0];
    r = malloc(l + 1); if (!r) nomem();
    strncpy(r, p->string + a[0], l);
    r[l] = '\0';
    return r;
}

int _pacc_ref_streq(ref_t a, char *b, struct _pacc_parser *p) {
    /* XXX this could be made quicker */
    if (strlen(b) != (size_t)(a[1] - a[0])) return 0;
    return strncmp(p->string + a[0], b, a[1] - a[0]) == 0; 
}

/* Find the largest available prime which is smaller than the target
 * bucket count. This exponential selection of primes was generated by
 * Dan Bernstein's primegen-0.97 package, using the following:

perl -le '$x=1;while(($e=int(exp($x/1)))<2**32){print "./primes ",$e," ",100+$e," | sed 1q";++$x}' | sh

 * except that I replaced 2 with 3.
 */
static void _pacc_set_bkt_cnt(struct _pacc_parser *p) {
    static unsigned int primes[] = {
	3, 7, 23, 59, 149, 409, 1097, 2999, 8111, 22027, 59879, 162779, 442439,
	1202609, 3269029, 8886113, 24154957, 65659969, 178482319, 485165237,
	1318815761, 3584912873U
    };
    int i, p_sz = sizeof(primes) / sizeof(*primes);
    unsigned long bkt_cnt = n_rules * (p->input_length + 1) / 100;

    for (i = 1; i < p_sz; ++i) {
	if (primes[i] > bkt_cnt) break;
    }
    p->m_bkt_cnt = primes[i - 1];
}

static struct _pacc_parser *_pacc_parser_new(char *s, off_t l) {
    unsigned int i;
    struct _pacc_parser *r;

    r = realloc(0, sizeof *r);
    if (!r) nomem();
    r->string = s;
    r->input_length = l;
    _pacc_set_bkt_cnt(r);
    r->m_bkt = realloc(0, sizeof(struct intermed *) * r->m_bkt_cnt);
    if (!r->m_bkt) nomem();
    r->m_valid = realloc(0, 2 * r->m_bkt_cnt);
    for (i = 0; i < r->m_bkt_cnt; ++i) {
	r->m_bkt[i] = 0;
	r->m_valid[i * 2] = 0; /* valid */
	r->m_valid[i * 2 + 1] = 0; /* allocated */
    }
    r->m_chain_max = 0;
    r->cont_st = 0;
    r->cont_p = r->cont_alloc = 0;
    return r;
}

/* hash chains */
static struct intermed *_pacc_result(struct _pacc_parser *p, off_t col, long rule) {
    unsigned char i;
    unsigned int h;
    struct intermed *bkt, *r;

    assert(col < p->input_length + 1);
    Trace fprintf(stderr, "_pacc_result(%ld, %ld)\n", col, rule);
    h = (col + (rule << 6) + (rule << 16) - rule) % p->m_bkt_cnt;
    bkt = p->m_bkt[h];
    for (i = 0; i < p->m_valid[h * 2]; ++i) {
	r = bkt + i;
	if (r->col == col && r->rule >> 4 == rule)
	    return r;
    }
    if (i == p->m_valid[h * 2 + 1]) {
	if (i == 255) panic("bucket too large");
	if (i + 1 > p->m_chain_max) p->m_chain_max = i + 1;
	p->m_bkt[h] = bkt = realloc(bkt, p->m_chain_max * sizeof(struct intermed));
	if (!bkt) nomem();
	p->m_valid[h * 2 + 1] = p->m_chain_max;
    }
    r = bkt + i;
    /* Initialize the new element. */
    r->col = col; r->rule = rule << 4 | uncomputed;
    r->evlis = 0;
    r->ev_alloc = r->ev_valid = 0;
    /* Correct use of a side effect in an (unfailing) assert. */
    assert((r->expr_id = 0) == 0);
    ++(p->m_valid[h * 2]);
    return r;
}

static int engine(struct _pacc_parser *_pacc, PACC_TYPE *result) {
    enum status status;
    int cont, st;
    off_t col, rule_col;
    int evaluating;
    struct intermed *last;
    col = 0;
    cont = -1;
    evaluating = 0;
    size_t pos, _pacc_ev_i;

#EMIT_ENGINE

    col = 0;
    cur = _pacc_result(_pacc, col, start_rule_id);
    if (parsed && !evaluating && (cur->rule & 3) == parsed) {
	char *stack_save;

	Trace fprintf(stderr, "PARSED! Time to start eval...\n");
	evaluating = 1;
	_pacc_ev_i = 0;
    eval_loop:
	Trace fprintf(stderr, "eval loop with _pacc_ev_i == %d\n", _pacc_ev_i);
	stack_save = _pacc->cont_p;
    eval1:
	while (_pacc_ev_i < cur->ev_valid) {
	    int col, rule;
	    rule = cur->evlis[_pacc_ev_i].call_id;
	    col = cur->evlis[_pacc_ev_i].col;
	    ++_pacc_ev_i;
	    Trace fprintf(stderr, "eval loop: r%d @ c%d\n", rule, col);
	    _pacc_Push(cur);
	    _pacc_Push(_pacc_ev_i);
	    cur = _pacc_result(_pacc, col, rule);
	    _pacc_ev_i = 0;
	}
	if ((cur->rule & 3) != evaluated && cur->expr_id) {
	    st = cur->expr_id;
	    col = cur->col;
	    goto top;
	}
    _pacc_expr_done:
	cur->rule = (cur->rule & ~3) | evaluated;
	if (_pacc->cont_p != stack_save) {
	    _pacc_Pop(_pacc_ev_i);
	    _pacc_Pop(cur);
	    goto eval1;
	}
	Trace fprintf(stderr, "eval finished\n");
	goto contin;
    }

    //assert(cur == _pacc->m);
    if ((cur->rule & 3) == no_parse) {
       size_t i;
       printf("expected ");
       for (i = 0; i < _pacc_err_valid; ++i) {
           printf("%s", _pacc_err[i]);
           if (i + 1 < _pacc_err_valid) {
               printf(", ");
               if (i + 2 == _pacc_err_valid) printf("or ");
           }
       }
       printf(" at column %ld\n", _pacc_err_col);
    }

    Instr {
	unsigned char min;
	unsigned int i;
	unsigned long a, v;

	a = v = 0;
	min = _pacc->m_chain_max;
	for (i = 0; i < _pacc->m_bkt_cnt; ++i) {
	    unsigned char valid = _pacc->m_valid[i * 2];
	    unsigned char alloc = _pacc->m_valid[i * 2 + 1];
	    fprintf(stderr, "%d/%d ", valid, alloc);
	    v += valid; a += alloc;
	    if (alloc < min)
		min = alloc;
	}
	fprintf(stderr, "\n");
	fprintf(stderr, "used %u buckets\n", _pacc->m_bkt_cnt);
	fprintf(stderr, "chain length from %d to %d\n", min, _pacc->m_chain_max);
	fprintf(stderr, "total used/allocated: %ld/%ld\n", v, a);
    }
    if ((cur->rule & 3) == evaluated) {
	Trace fprintf(stderr, "parsed with value " TYPE_PRINTF "\n", cur->value.u0); /* XXX u0 */
	*result = cur->value.u0;
    } else if ((cur->rule & 3) == parsed) {
	Trace fprintf(stderr, "parsed with void value\n");
    } else Trace fprintf(stderr, "not parsed\n");
    return (cur->rule & 3) == evaluated;

contin:
    Trace fprintf(stderr, "continuing in state %d\n", cont);
    st = cont;
    goto top;
}

int parse(char *addr, off_t l, PACC_TYPE *result) {
    struct _pacc_parser *p;
    /* XXX the result should live in the _pacc_parser */
    p = _pacc_parser_new(addr, l);
    return engine(p, result);
}
