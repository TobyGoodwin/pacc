#undef NDEBUG

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define Trace if (0)
#define Instr if (0)

static char *string;

#define ST_STACK_BODGE 2000
static int st_stack[ST_STACK_BODGE];
static int st_ptr = 0;

static void pushcont(int c) {
    if (st_ptr == ST_STACK_BODGE) {
	fprintf(stderr, "st_stack overflow\n");
	exit(1);
    }
    assert(st_ptr >= 0);
    Trace fprintf(stderr, "pushcont(%d) -> stack[%d]\n", c, st_ptr);
    st_stack[st_ptr++] = c;
}
static int popcont(void) {
    Trace fprintf(stderr, "popcont() stack[%d] -> %d\n", st_ptr - 1, st_stack[st_ptr - 1]);
    return st_stack[--st_ptr];
}

static void panic(const char *e) {
    fprintf(stderr, "pacc: panic: %s\n", e);
    exit(1);
}

static void nomem(void) {
    panic("out of memory");
}

static char *copy(int from, int to) {
    char *r;
    int l;
    Trace fprintf(stderr, "copy(%d, %d)\n", from, to);
    l = to - from;
    r = realloc(0, l + 1);
    if (r) {
	memcpy(r, string + from, l); 
	r[l] = '\0';
    }
    return r;
}
#define match() copy(col, col_expr)
#define rmatch() copy(col_expr, cur->remainder)

#define COL_STACK_BODGE 25
static int col_stack[COL_STACK_BODGE];
static int col_ptr = 0;
static void pushcol(int c) {
    if (col_ptr == COL_STACK_BODGE) {
	fprintf(stderr, "col_stack overflow\n");
	exit(1);
    }
    Trace fprintf(stderr, "push(%d) -> col_stack[%d]\n", c, col_ptr);
    col_stack[col_ptr++] = c;
}
static int popcol(void) {
    Trace fprintf(stderr, "pop() col_stack[%d] -> %d\n", col_ptr - 1, col_stack[col_ptr - 1]);
    return col_stack[--col_ptr];
}

/* a "thr" is a thunk or a rule/column pair */
enum thr { thr_thunk = 71, thr_bound, thr_rule, thr_col };
struct thunkrule {
    enum thr discrim;
    int x;
    int col;
};

enum status {
    no_parse, parsed, evaluated, uncomputed
};

/* A dynamic array of error strings */
char **_pacc_err = 0;
size_t _pacc_err_alloc = 0;
size_t _pacc_err_valid = 0;
off_t _pacc_err_col;

#EMIT_DECLARATIONS

struct intermed {
    /* Where in the matrix are we? */
    long rule; off_t col;
    //enum status status;
    union yy_union value; /* semantic value XXX needs to use g_name */
    off_t remainder; /* unparsed string */
    union {
	off_t col;
	long core;
    } *evlis;
    size_t ev_alloc;
    size_t ev_valid;
#if 0
    /* A dynamic array of "call or eval"s. */
    long *cores;
    size_t cores_alloc;
    size_t cores_valid;
    /* A dynamic array of columns. */
    off_t *cols;
    size_t cols_alloc;
    size_t cols_valid;
#endif
};

static struct intermed *cur;

static void _pacc_save_col(off_t c) {
    if (cur->ev_valid == cur->ev_alloc) {
	cur->ev_alloc = cur->ev_alloc * 2 + 1;
	cur->evlis = realloc(cur->evlis, cur->ev_alloc * sizeof(*cur->evlis));
	if (!cur->evlis) nomem();
    }
    cur->evlis[cur->ev_valid].col = c;
    ++cur->ev_valid;
}

static void _pacc_save_core(long c, int type, int cols) {
    Trace fprintf(stderr, "_pacc_save_core(%ld, %d, %d)\n", c, type, cols);
    if (cur->ev_valid == cur->ev_alloc) {
	cur->ev_alloc = cur->ev_alloc * 2 + 1;
	cur->evlis = realloc(cur->evlis, cur->ev_alloc * sizeof(*cur->evlis));
	if (!cur->evlis) nomem();
    }
    assert(cols < 4); /* property of the encoding */
    assert(cols < 2); /* property of the current use of cols */
    assert(type - thr_thunk < 4);
    /* XXX is this really an assertion? In principle, an enormous input
     * could blow it away. */
    assert(c << 4 > c);
    cur->evlis[cur->ev_valid].core = c << 4 | (type - thr_thunk) << 2 | cols;
    assert(c == cur->evlis[cur->ev_valid].core >> 4);
    assert(type == (cur->evlis[cur->ev_valid].core >> 2 & 3) + thr_thunk);
    assert(cols == (cur->evlis[cur->ev_valid].core & 3));
    ++cur->ev_valid;
}

#if 0
static void _pacc_save_col(off_t c) {
    if (cur->cols_valid == cur->cols_alloc) {
	cur->cols_alloc = cur->cols_alloc * 2 + 1;
	cur->cols = realloc(cur->cols, cur->cols_alloc * sizeof(c));
	if (!cur->cols) nomem();
    }
    cur->cols[cur->cols_valid] = c;
    ++cur->cols_valid;
}

static void _pacc_save_core(long c, int type, int cols) {
    if (cur->cores_valid == cur->cores_alloc) {
	cur->cores_alloc = cur->cores_alloc * 2 + 1;
	cur->cores = realloc(cur->cores, cur->cores_alloc * sizeof(c));
	if (!cur->cores) nomem();
    }
    /* XXX are these really assertions? */
    assert(c << 4 > c);
    assert(cols < 4); assert(type - thr_thunk < 4);
    cur->cores[cur->cores_valid] = c << 4 | (type - thr_thunk) << 2 | cols;
    ++cur->cores_valid;
}
#endif

static int input_length;

/* a pacc parser */
struct _pacc_parser {
    struct intermed **m_bkt;
    unsigned int m_bkt_cnt;
    unsigned char *m_valid;
    unsigned char m_chain_max;
};

static struct _pacc_parser *_pacc_parser_new(void) {
    unsigned int i;
    size_t m_size;
    struct _pacc_parser *r;

    r = realloc(0, sizeof *r);
    if (!r) nomem();
    m_size = n_rules * (input_length + 1);
    r->m_bkt_cnt = 1409; /* XXX: some prime */
    r->m_bkt = realloc(0, sizeof(struct intermed *) * r->m_bkt_cnt);
    if (!r->m_bkt) nomem();
    r->m_valid = realloc(0, 2 * r->m_bkt_cnt);
    for (i = 0; i < r->m_bkt_cnt; ++i) {
	r->m_bkt[i] = 0;
	r->m_valid[i * 2] = 0; /* valid */
	r->m_valid[i * 2 + 1] = 0; /* allocated */
    }
    r->m_chain_max = 0;
    return r;
}

/* hash chains */
static struct intermed *_pacc_result(struct _pacc_parser *p, off_t col, long rule) {
    unsigned char i;
    unsigned int h;
    struct intermed *bkt, *r;
    assert(col < input_length + 1);
    //assert(rule < n_rules); Not any more!
    //fprintf(stderr, "_pacc_result(%d, %d)\n", col, rule);
    h = (col + (rule << 6) + (rule << 16) - rule) % p->m_bkt_cnt;
    bkt = p->m_bkt[h];
    for (i = 0; i < p->m_valid[h * 2]; ++i) {
	r = bkt + i;
	if (r->col == col && r->rule >> 4 == rule)
	    return r;
    }
    if (i == p->m_valid[h * 2 + 1]) {
	if (i == 255) panic("bucket too large");
	if (i + 1 > p->m_chain_max) p->m_chain_max = i + 1;
	p->m_bkt[h] = bkt = realloc(bkt, p->m_chain_max * sizeof(struct intermed));
	if (!bkt) nomem();
	p->m_valid[h * 2 + 1] = p->m_chain_max;
    }
    r = bkt + i;
    /* Initialize the new element. */
    r->col = col; r->rule = rule << 4 | uncomputed;
    r->evlis = 0;
    r->ev_alloc = r->ev_valid = 0;
    ++(p->m_valid[h * 2]);
    return r;
}

#define M_STACK_BODGE 500
static struct intermed *m_stack[M_STACK_BODGE];
static int m_ptr = 0;
static void pushm(struct intermed *i) {
    if (m_ptr == M_STACK_BODGE) { printf("out of m stack space\n"); exit(0); }
    m_stack[m_ptr++] = i;
}
static struct intermed *popm(void) { return m_stack[--m_ptr]; }

static int engine(struct _pacc_parser *_pacc, PACC_TYPE *result) {
    enum status status;
    int cont, st;
    int col, rule_col, col_expr;
    int _pacc_i;
    int evaluating;
    struct intermed *last;
    col = 0;
    cont = -1;
    evaluating = 0;
    size_t pos, _pacc_ev_i;

#EMIT_ENGINE

    cur = _pacc_result(_pacc, 0, start_rule_id);
    if (parsed && !evaluating && (cur->rule & 3) == parsed) {
	Trace fprintf(stderr, "PARSED! Time to start eval...\n");
	evaluating = 1;
	_pacc_ev_i = 0;
    eval_loop:
	Trace fprintf(stderr, "eval loop with _pacc_ev_i == %d\n", _pacc_ev_i);
	if (_pacc_ev_i < cur->ev_valid) {
	    enum thr discrim = thr_thunk + (cur->evlis[_pacc_ev_i].core >> 2 & 3);
	    if (discrim == thr_rule || discrim == thr_bound) {
		int col, rule;
		rule = cur->evlis[_pacc_ev_i].core >> 4;
		++_pacc_ev_i;
		assert(_pacc_ev_i < cur->ev_valid);
		col = cur->evlis[_pacc_ev_i].col;
		++_pacc_ev_i;
		Trace fprintf(stderr, "eval loop: r%d @ c%d\n", rule, col);
		pushm(cur); pushcont(_pacc_ev_i);
		cur = _pacc_result(_pacc, col, rule);
		_pacc_ev_i = 0;
		goto eval_loop;
	    } else {
		st = cur->evlis[_pacc_ev_i].core >> 4;
		++_pacc_ev_i;
		assert(_pacc_ev_i < cur->ev_valid);
		col = cur->evlis[_pacc_ev_i].col; ++_pacc_ev_i;
		/* XXX currently, we only permit one additional column,
		 * which always goes into col_expr. */
		if (cur->evlis[_pacc_ev_i - 2].core & 3) {
		    assert(_pacc_ev_i < cur->ev_valid);
		    col_expr = cur->evlis[_pacc_ev_i].col; ++_pacc_ev_i;
		}
		goto top;
	    }
	    goto eval_loop;
	}
	cur->rule = (cur->rule & ~3) | evaluated;
	if (m_ptr) {
	    _pacc_ev_i = popcont(); cur = popm();
	    goto eval_loop;
	}
	Trace fprintf(stderr, "eval finished\n");
	goto contin;
    }

    //assert(cur == _pacc->m);
    if ((cur->rule & 3) == no_parse) {
       size_t i;
       printf("expected ");
       for (i = 0; i < _pacc_err_valid; ++i) {
           printf("%s", _pacc_err[i]);
           if (i + 1 < _pacc_err_valid) {
               printf(", ");
               if (i + 2 == _pacc_err_valid) printf("or ");
           }
       }
       printf(" at column %ld\n", _pacc_err_col);
    }

    Instr {
	unsigned int i;
	unsigned long a, v;

	fprintf(stderr, "chain length is %d\n", _pacc->m_chain_max);
	a = v = 0;
	for (i = 0; i < _pacc->m_bkt_cnt; ++i) {
	    fprintf(stderr, "%d/%d ", _pacc->m_valid[i * 2], _pacc->m_valid[i * 2 + 1]);
	    v += _pacc->m_valid[i * 2];
	    a += _pacc->m_valid[i * 2 + 1];
	}
	fprintf(stderr, "\n%ld/%ld\n", v, a);
    }
    if ((cur->rule & 3) == evaluated) {
	Trace fprintf(stderr, "parsed with value " TYPE_PRINTF "\n", cur->value.u0); /* XXX u0 */
	*result = cur->value.u0;
    } else if ((cur->rule & 3) == parsed) {
	Trace fprintf(stderr, "parsed with void value\n");
    } else Trace fprintf(stderr, "not parsed\n");
    return (cur->rule & 3) == evaluated;

contin:
    Trace fprintf(stderr, "continuing in state %d\n", cont);
    st = cont;
    goto top;
}

int parse(char *addr, off_t l, PACC_TYPE *result) {
    struct _pacc_parser *p;
    /* XXX string and input_length should live in the _pacc_parser
     * struct, so should the result
     */
    string = addr;
    input_length = l;
    p = _pacc_parser_new();
    return engine(p, result);
}
